<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>VOID REAPER — Space Shooter</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --red: #ff0033;
    --red-glow: rgba(255,0,51,0.6);
    --bg: #030008;
    --text: #fff;
    --accent: #ff3355;
  }

  body {
    background: var(--bg);
    font-family: 'Rajdhani', sans-serif;
    overflow: hidden;
    width: 100vw; height: 100vh;
    display: flex; align-items: center; justify-content: center;
    color: var(--text);
    cursor: crosshair;
  }

  canvas { display: block; touch-action: none; }

  .screen {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: radial-gradient(ellipse at center, #0d0018 0%, #030008 70%);
    z-index: 10;
    transition: opacity .4s;
  }
  .screen.hidden { opacity: 0; pointer-events: none; }
  .screen::before {
    content: '';
    position: absolute; inset: 0;
    background-image:
      radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,.6) 0%, transparent 100%),
      radial-gradient(1px 1px at 30% 60%, rgba(255,255,255,.4) 0%, transparent 100%),
      radial-gradient(1px 1px at 50% 10%, rgba(255,255,255,.7) 0%, transparent 100%),
      radial-gradient(1px 1px at 70% 80%, rgba(255,255,255,.5) 0%, transparent 100%),
      radial-gradient(1px 1px at 90% 40%, rgba(255,255,255,.6) 0%, transparent 100%),
      radial-gradient(1px 1px at 20% 90%, rgba(255,0,51,.8) 0%, transparent 100%),
      radial-gradient(1px 1px at 80% 15%, rgba(255,0,51,.6) 0%, transparent 100%);
    pointer-events: none; z-index: -1;
  }

  .logo {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: clamp(2.5rem, 8vw, 5.5rem);
    letter-spacing: 6px;
    text-transform: uppercase;
    color: #fff;
    text-align: center;
    text-shadow: 0 0 20px var(--red-glow), 0 0 60px var(--red-glow), 0 0 120px rgba(255,0,51,.3);
    margin-bottom: .2em;
    animation: pulse-glow 2s ease-in-out infinite alternate;
  }
  .tagline {
    font-size: clamp(.9rem, 2.5vw, 1.2rem);
    letter-spacing: 8px;
    color: var(--accent);
    margin-bottom: 3rem;
    text-transform: uppercase;
    opacity: .8;
  }
  @keyframes pulse-glow {
    from { text-shadow: 0 0 20px var(--red-glow), 0 0 60px var(--red-glow); }
    to   { text-shadow: 0 0 40px var(--red-glow), 0 0 100px rgba(255,0,51,.5), 0 0 200px rgba(255,0,51,.2); }
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: clamp(.85rem, 2.5vw, 1.1rem);
    font-weight: 700;
    letter-spacing: 4px;
    padding: .85em 2.5em;
    border: 2px solid var(--red);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    text-transform: uppercase;
    position: relative;
    overflow: hidden;
    margin: .4rem;
    transition: color .2s, box-shadow .2s;
  }
  .btn::before {
    content: ''; position: absolute; inset: 0;
    background: var(--red);
    transform: translateX(-100%);
    transition: transform .25s;
    z-index: -1;
  }
  .btn:hover::before { transform: translateX(0); }
  .btn:hover { box-shadow: 0 0 24px var(--red-glow); }
  .btn.primary { background: var(--red); }
  .btn.primary::before { background: #ff6680; }
  .btn-group { display: flex; flex-direction: column; align-items: center; gap: .5rem; }

  /* HUD */
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 20px;
    background: linear-gradient(to bottom, rgba(3,0,8,.9), transparent);
    z-index: 5; pointer-events: none;
  }
  .hud-score { font-family: 'Orbitron', monospace; font-size: clamp(1rem,3vw,1.5rem); font-weight: 700; color:#fff; text-shadow: 0 0 10px var(--red-glow); }
  .hud-score span { color: var(--accent); }


  #pauseBtn { position:fixed; top:12px; right:20px; z-index:6; pointer-events:all; font-size:.7rem; padding:.5em 1.2em; }

  .overlay-title { font-family:'Orbitron',monospace; font-weight:900; font-size:clamp(2rem,6vw,4rem); color:var(--red); text-shadow:0 0 30px var(--red-glow); margin-bottom:1rem; text-align:center; }
  .final-score { font-family:'Rajdhani',sans-serif; font-size:clamp(1.2rem,3vw,1.8rem); color:#ccc; margin-bottom:2rem; letter-spacing:2px; }
  .final-score strong { color:#fff; font-family:'Orbitron',monospace; font-size:1.3em; text-shadow:0 0 12px var(--red-glow); }

  /* Mobile controls */
  #mobileControls {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: none;
    justify-content: space-between;
    align-items: flex-end;
    padding: 20px;
    z-index: 5;
    pointer-events: none;
  }

  /* Left joystick — MOVE (blue tint) */
  #moveJoyZone {
    width: 130px; height: 130px;
    border-radius: 50%;
    border: 2px solid rgba(80,120,255,.35);
    background: rgba(80,120,255,.05);
    position: relative;
    pointer-events: all;
    touch-action: none;
  }
  #moveJoyZone::after {
    content: 'MOVE';
    font-family: 'Orbitron', monospace;
    font-size: .5rem; font-weight: 700; letter-spacing: 3px;
    color: rgba(100,140,255,.4);
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }
  #moveJoyKnob {
    width: 52px; height: 52px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 40%, rgba(120,160,255,.9), rgba(30,0,120,.8));
    border: 2px solid #6688ff;
    box-shadow: 0 0 16px rgba(100,120,255,.6);
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }

  /* Right joystick — AIM & FIRE (red) */
  #fireJoyZone {
    width: 130px; height: 130px;
    border-radius: 50%;
    border: 2px solid rgba(255,0,51,.4);
    background: rgba(255,0,51,.05);
    position: relative;
    pointer-events: all;
    touch-action: none;
  }
  #fireJoyZone::after {
    content: 'AIM & FIRE';
    font-family: 'Orbitron', monospace;
    font-size: .45rem; font-weight: 700; letter-spacing: 2px;
    color: rgba(255,0,51,.45);
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    white-space: nowrap;
  }
  #fireJoyKnob {
    width: 52px; height: 52px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 40%, rgba(255,80,100,.9), rgba(139,0,0,.8));
    border: 2px solid var(--red);
    box-shadow: 0 0 20px var(--red-glow), 0 0 40px rgba(255,0,51,.3);
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }

  @media (max-width: 768px), (pointer: coarse) {
    #mobileControls { display: flex; }
    #pauseBtn { top: 8px; right: 8px; }
  }

  @keyframes scorePop {
    0%   { transform: translateX(-50%) translateY(0)   scale(1);    opacity: 1; }
    15%  { transform: translateX(-50%) translateY(-8px) scale(1.15); opacity: 1; }
    100% { transform: translateX(-50%) translateY(-70px) scale(0.9); opacity: 0; }
  }
  .score-popup {
    position: fixed;
    font-family: 'Orbitron', monospace;
    font-size: 1rem; font-weight: 700;
    color: var(--accent);
    text-shadow: 0 0 8px var(--red-glow);
    pointer-events: none;
    animation: scorePop .8s ease-out forwards;
    z-index: 20;
    white-space: nowrap;
    text-align: center;
  }
  .score-popup.combo {
    font-size: 1.4rem;
    color: #ff4400;
    text-shadow: 0 0 16px rgba(255,80,0,0.9), 0 0 32px rgba(255,40,0,0.5);
    animation: scorePop 1s ease-out forwards;
  }
  .score-popup.boss-kill {
    font-size: 1.6rem;
    color: #ff00ff;
    text-shadow: 0 0 20px rgba(255,0,255,0.9), 0 0 40px rgba(200,0,255,0.6);
    animation: scorePop 1.4s ease-out forwards;
  }
</style>
</head>
<body>

<!-- START -->
<div class="screen" id="startScreen">
  <div class="logo">VOID REAPER</div>
  <div class="tagline">Infinite Survival · Deep Space</div>
  <div class="btn-group">
    <button class="btn primary" id="startBtn">BEGIN MISSION</button>
  </div>
  <div style="margin-top:2rem;font-size:.75rem;letter-spacing:2px;opacity:.4;text-align:center;line-height:2.2">
    WASD / ARROWS — MOVE &nbsp;|&nbsp; MOUSE AIM + CLICK / SPACE — FIRE<br>
    MOBILE: LEFT STICK MOVE · RIGHT STICK AIM &amp; FIRE &nbsp;|&nbsp; ESC — PAUSE
  </div>
</div>

<!-- PAUSE -->
<div class="screen hidden" id="pauseScreen">
  <div class="overlay-title">PAUSED</div>
  <div class="btn-group">
    <button class="btn primary" id="resumeBtn">RESUME</button>
    <button class="btn" id="restartFromPauseBtn">RESTART</button>
    <button class="btn" id="quitBtn">QUIT TO MENU</button>
  </div>
</div>

<!-- GAME OVER -->
<div class="screen hidden" id="gameOverScreen">
  <div class="overlay-title">ELIMINATED</div>
  <div class="final-score">FINAL SCORE &nbsp;·&nbsp; <strong id="finalScore">0</strong></div>
  <div class="btn-group">
    <button class="btn primary" id="restartBtn">TRY AGAIN</button>
    <button class="btn" id="menuBtn">MAIN MENU</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" style="display:none;">
  <div class="hud-score">SCORE &nbsp;<span id="scoreDisplay">0</span></div>

</div>
<button class="btn" id="pauseBtn" style="display:none;">❚❚ PAUSE</button>

<!-- CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- MOBILE CONTROLS -->
<div id="mobileControls">
  <div id="moveJoyZone"><div id="moveJoyKnob"></div></div>
  <div id="fireJoyZone"><div id="fireJoyKnob"></div></div>
</div>

<script>
/* ═══════════════════════════════════════════════════
   VOID REAPER — Space Shooter
   Left joystick  → move player
   Right joystick → aim + auto-fire while pushed
   PC mouse       → aims ship; click/space fires
   ═══════════════════════════════════════════════════ */

const canvas = document.getElementById('gameCanvas');
const ctx    = canvas.getContext('2d');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// ── UI refs ──────────────────────────────────────────
const scrStart   = document.getElementById('startScreen');
const scrPause   = document.getElementById('pauseScreen');
const scrOver    = document.getElementById('gameOverScreen');
const hud        = document.getElementById('hud');
const pauseBtn   = document.getElementById('pauseBtn');
const scoreDisp  = document.getElementById('scoreDisplay');
const finalScoreEl = document.getElementById('finalScore');

function showScreen(name) {
  scrStart.classList.toggle('hidden', name !== 'start');
  scrPause.classList.toggle('hidden', name !== 'pause');
  scrOver .classList.toggle('hidden', name !== 'over');
  hud.style.display      = name === 'game' ? 'flex'  : 'none';
  pauseBtn.style.display = name === 'game' ? 'block' : 'none';
}
showScreen('start');

// ── Game state ───────────────────────────────────────
let state = 'menu'; // menu | playing | paused | over
let score = 0, hp = 100;
let spawnTimer = 0, spawnInterval = 120, diffTimer = 0;

// ── Entities ─────────────────────────────────────────
let stars = [], bullets = [], enemies = [], enemyBullets = [], particles = [], medkits = [];
let medkitTimer = 0;
const MEDKIT_INTERVAL = 600; // 10 seconds at 60fps

// ── Boss System ───────────────────────────────────────
let boss = null;           // active boss object or null
let bossState = 'none';    // 'none' | 'warning' | 'active' | 'dying'
let bossWarningTimer = 0;
let bossScoreThreshold = 1000; // next boss trigger score
let bossBullets = [];

// ── Combo System ──────────────────────────────────────
let combo = 0;
let comboTimer = 0;
const COMBO_DECAY = 120; // 2 seconds at 60fps
let comboMultiplier = 1;

// ── Screen Shake ──────────────────────────────────────
let shakeIntensity = 0;
let shakeDuration  = 0;
let shakeX = 0, shakeY = 0;

// ── Player ───────────────────────────────────────────
const player = {
  x: 0, y: 0, w: 36, h: 44,
  speed: 4,
  shootCooldown: 0, shootDelay: 18,
  invincible: 0,
  angle: -Math.PI / 2,
  targetAngle: -Math.PI / 2,
};

// ── Keyboard / mouse ─────────────────────────────────
const keys = {};
let mousePos = { x: 0, y: 0 };
let mouseDown = false;

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Escape') togglePause();
  if (e.code === 'Space')  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
canvas.addEventListener('mousemove', e => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
canvas.addEventListener('mousedown', e => { if (e.button === 0) mouseDown = true; });
canvas.addEventListener('mouseup',   e => { if (e.button === 0) mouseDown = false; });

// ── Joysticks — unified document-level touch tracker ─
const moveJoyZone = document.getElementById('moveJoyZone');
const moveJoyKnob = document.getElementById('moveJoyKnob');
const fireJoyZone = document.getElementById('fireJoyZone');
const fireJoyKnob = document.getElementById('fireJoyKnob');
const MAX_JOY = 40;

let moveJoy = { dx: 0, dy: 0, active: false };
let fireJoy = { dx: 0, dy: 0, active: false };
let moveTouchId = -1, fireTouchId = -1;
let moveOrigin = null, fireOrigin = null;

function joyCenter(el) {
  const r = el.getBoundingClientRect();
  return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
}
function applyJoy(joy, knob, origin, tx, ty) {
  let dx = tx - origin.x, dy = ty - origin.y;
  const d = Math.hypot(dx, dy);
  if (d > MAX_JOY) { dx *= MAX_JOY / d; dy *= MAX_JOY / d; }
  joy.dx = dx / MAX_JOY; joy.dy = dy / MAX_JOY;
  knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}
function resetJoy(joy, knob) {
  joy.dx = 0; joy.dy = 0; joy.active = false;
  knob.style.transform = 'translate(-50%, -50%)';
}

// Joystick zones handle their own touchstart to avoid blocking buttons
moveJoyZone.addEventListener('touchstart', e => {
  e.preventDefault();
  if (moveTouchId !== -1) return;
  const t = e.changedTouches[0];
  moveTouchId = t.identifier;
  moveOrigin  = joyCenter(moveJoyZone);
  moveJoy.active = true;
  applyJoy(moveJoy, moveJoyKnob, moveOrigin, t.clientX, t.clientY);
}, { passive: false });

fireJoyZone.addEventListener('touchstart', e => {
  e.preventDefault();
  if (fireTouchId !== -1) return;
  const t = e.changedTouches[0];
  fireTouchId = t.identifier;
  fireOrigin  = joyCenter(fireJoyZone);
  fireJoy.active = true;
  applyJoy(fireJoy, fireJoyKnob, fireOrigin, t.clientX, t.clientY);
}, { passive: false });

// Move and end tracked at document level so finger can roam freely
document.addEventListener('touchmove', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === moveTouchId && moveOrigin) {
      e.preventDefault();
      applyJoy(moveJoy, moveJoyKnob, moveOrigin, t.clientX, t.clientY);
    }
    if (t.identifier === fireTouchId && fireOrigin) {
      e.preventDefault();
      applyJoy(fireJoy, fireJoyKnob, fireOrigin, t.clientX, t.clientY);
    }
  }
}, { passive: false });

function onTouchEnd(e) {
  for (const t of e.changedTouches) {
    if (t.identifier === moveTouchId) { moveTouchId = -1; moveOrigin = null; resetJoy(moveJoy, moveJoyKnob); }
    if (t.identifier === fireTouchId) { fireTouchId = -1; fireOrigin = null; resetJoy(fireJoy, fireJoyKnob); }
  }
}
document.addEventListener('touchend',    onTouchEnd, { passive: true });
document.addEventListener('touchcancel', onTouchEnd, { passive: true });

// ── Buttons ──────────────────────────────────────────
function bindBtn(id, fn) {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('click', e => { e.stopPropagation(); fn(); });
}
bindBtn('startBtn',            startGame);
bindBtn('resumeBtn',           togglePause);
bindBtn('restartFromPauseBtn', () => { startGame(); });
bindBtn('quitBtn',             () => { state = 'menu'; showScreen('start'); });
bindBtn('restartBtn',          startGame);
bindBtn('menuBtn',             () => { state = 'menu'; showScreen('start'); });
pauseBtn.addEventListener('click', e => { e.stopPropagation(); togglePause(); });

// ══════════════════════════════════════════════════════
//  INIT / START
// ══════════════════════════════════════════════════════
function startGame() {
  score = 0; hp = 100;
  bullets = []; enemies = []; enemyBullets = []; particles = []; medkits = [];
  medkitTimer = 0;
  spawnTimer = 0; spawnInterval = 120; diffTimer = 0;
  boss = null; bossState = 'none'; bossWarningTimer = 0;
  bossScoreThreshold = 1000; bossBullets = [];
  combo = 0; comboTimer = 0; comboMultiplier = 1;
  shakeIntensity = 0; shakeDuration = 0;
  player.x = canvas.width  / 2;
  player.y = canvas.height / 2;
  player.shootCooldown = 0;
  player.invincible    = 0;
  player.angle         = -Math.PI / 2;
  player.targetAngle   = -Math.PI / 2;
  initStars();
  updateHUD();
  state = 'playing';
  showScreen('game');
}

function togglePause() {
  if      (state === 'playing') { state = 'paused'; showScreen('pause'); }
  else if (state === 'paused')  { state = 'playing'; showScreen('game'); }
}

function initStars() {
  stars = [];
  for (let i = 0; i < 180; i++) {
    stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height,
      r: Math.random()*1.5+.3, speed: Math.random()*.4+.1,
      alpha: Math.random()*.7+.3, red: Math.random() < .07 });
  }
}

// ══════════════════════════════════════════════════════
//  SPAWN
// ══════════════════════════════════════════════════════
function spawnEnemy() {
  const side = Math.floor(Math.random()*4);
  const W = canvas.width, H = canvas.height;
  let x, y;
  if      (side===0){ x=Math.random()*W; y=-30; }
  else if (side===1){ x=Math.random()*W; y=H+30; }
  else if (side===2){ x=-30; y=Math.random()*H; }
  else              { x=W+30; y=Math.random()*H; }
  const types = ['scout','fighter','bomber'];
  const type  = types[Math.floor(Math.random()*types.length)];
  const C = { scout:{hp:20,speed:2.0,size:20,shootDelay:90,color:'#ff3355',pts:10},
               fighter:{hp:40,speed:1.4,size:28,shootDelay:70,color:'#ff6600',pts:20},
               bomber:{hp:70,speed:.9,size:36,shootDelay:50,color:'#cc00ff',pts:30} }[type];
  enemies.push({ x,y,type,w:C.size,h:C.size,hp:C.hp,maxHp:C.hp,speed:C.speed,
    shootTimer:Math.random()*C.shootDelay,shootDelay:C.shootDelay,color:C.color,pts:C.pts,angle:0 });
}

function spawnMedkit() {
  const pad = 80;
  const x = pad + Math.random() * (canvas.width  - pad*2);
  const y = pad + Math.random() * (canvas.height - pad*2);
  medkits.push({ x, y, size: 36, pulse: 0 });
}

// ══════════════════════════════════════════════════════
//  UPDATE
// ══════════════════════════════════════════════════════
function update() {
  // Difficulty ramp
  if (++diffTimer % 600 === 0) spawnInterval = Math.max(30, spawnInterval - 8);

  // Movement (keyboard + left joystick — does NOT affect facing)
  let mdx = 0, mdy = 0;
  if (keys['ArrowLeft']  || keys['KeyA']) mdx -= 1;
  if (keys['ArrowRight'] || keys['KeyD']) mdx += 1;
  if (keys['ArrowUp']    || keys['KeyW']) mdy -= 1;
  if (keys['ArrowDown']  || keys['KeyS']) mdy += 1;
  if (moveJoy.active) { mdx += moveJoy.dx; mdy += moveJoy.dy; }
  const mlen = Math.hypot(mdx, mdy);
  if (mlen > 0) { mdx /= mlen; mdy /= mlen; }
  player.x = Math.max(player.w/2, Math.min(canvas.width  - player.w/2, player.x + mdx*player.speed));
  player.y = Math.max(player.h/2, Math.min(canvas.height - player.h/2, player.y + mdy*player.speed));

  // Aim direction
  const fireJoyPushed = fireJoy.active && Math.hypot(fireJoy.dx, fireJoy.dy) > 0.12;
  if (fireJoyPushed) {
    player.targetAngle = Math.atan2(fireJoy.dy, fireJoy.dx) + Math.PI/2;
  } else {
    const adx = mousePos.x - player.x, ady = mousePos.y - player.y;
    if (Math.hypot(adx, ady) > 5) player.targetAngle = Math.atan2(ady, adx) + Math.PI/2;
  }
  let da = player.targetAngle - player.angle;
  while (da >  Math.PI) da -= Math.PI*2;
  while (da < -Math.PI) da += Math.PI*2;
  player.angle += da * 0.2;

  // Shoot
  if (player.shootCooldown > 0) player.shootCooldown--;
  if ((mouseDown || keys['Space'] || fireJoyPushed) && player.shootCooldown === 0) {
    fireBullet();
    player.shootCooldown = player.shootDelay;
  }
  if (player.invincible > 0) player.invincible--;

  // Boss trigger check
  if (bossState==='none' && score >= bossScoreThreshold) {
    bossState='warning'; bossWarningTimer=180; // 3 seconds warning
  }

  // Boss warning countdown
  if (bossState==='warning') {
    bossWarningTimer--;
    if (bossWarningTimer<=0) spawnBoss();
  }

  // Boss update
  if (bossState==='active' && boss) updateBoss();

  // Normal enemy spawn (suppressed during boss)
  if (bossState==='none' || bossState==='dying') {
    if (++spawnTimer >= spawnInterval) {
      spawnTimer = 0; spawnEnemy();
      if (Math.random() < .3) spawnEnemy();
    }
  }

  // Player bullets
  bullets = bullets.filter(b => {
    b.x += b.vx; b.y += b.vy;
    return b.x > -20 && b.x < canvas.width+20 && b.y > -20 && b.y < canvas.height+20;
  });

  // Enemy & boss bullets
  enemyBullets = enemyBullets.filter(b => {
    b.x += b.vx; b.y += b.vy;
    if (player.invincible === 0 && hitCB(b.x,b.y,5,player.x,player.y,player.w,player.h)) {
      const dmg = b.boss ? (Math.floor(Math.random()*8)+10) : (Math.floor(Math.random()*6)+5);
      hp = Math.max(0, hp - dmg);
      player.invincible = 40;
      spawnParticles(player.x,player.y,'#ff0033',8);
      triggerShake(b.boss ? 10 : 5, b.boss ? 20 : 12);
      updateHUD();
      if (hp <= 0) { triggerShake(18,40); gameOver(); }
      return false;
    }
    return b.x > -20 && b.x < canvas.width+20 && b.y > -20 && b.y < canvas.height+20;
  });

  // Boss bullets movement (handled in enemyBullets array, flagged with .boss=true)
  // bossBullets are added to enemyBullets with boss:true flag — handled above

  // ── Advanced Enemy AI ──────────────────────────────
  enemies.forEach((e, ei) => {
    const adx=player.x-e.x, ady=player.y-e.y, dist=Math.hypot(adx,ady)||1;
    e.angle = Math.atan2(ady,adx)+Math.PI/2;

    // Repel from other enemies to prevent stacking
    let repX=0, repY=0;
    enemies.forEach((o,oi) => {
      if (oi===ei) return;
      const dx=e.x-o.x, dy=e.y-o.y, d=Math.hypot(dx,dy)||1;
      if (d < 60) { repX+=dx/d*(60-d)*0.04; repY+=dy/d*(60-d)*0.04; }
    });
    e.x+=repX; e.y+=repY;

    if (e.type==='scout') {
      // Zig-zag + random dash
      e.zigTimer=(e.zigTimer||0)+1;
      if (!e.zigDir || e.zigTimer>60+Math.random()*40) { e.zigDir=(Math.random()-0.5)*3; e.zigTimer=0; }
      const perpX=-ady/dist, perpY=adx/dist;
      e.x += (adx/dist)*e.speed + perpX*e.zigDir;
      e.y += (ady/dist)*e.speed + perpY*e.zigDir;
      // Random dash
      e.dashTimer=(e.dashTimer||0)+1;
      if (e.dashTimer>120+Math.random()*180) { e.dashTimer=0; e.dashX=adx/dist*8; e.dashY=ady/dist*8; e.dashFrames=10; }
      if (e.dashFrames>0) { e.x+=e.dashX; e.y+=e.dashY; e.dashFrames--; }
    } else if (e.type==='fighter') {
      // Strafe sideways, keep medium distance
      e.strafeTimer=(e.strafeTimer||0)+1;
      if (!e.strafeDir || e.strafeTimer>90) { e.strafeDir=Math.random()<0.5?1:-1; e.strafeTimer=0; }
      const perpX=-ady/dist, perpY=adx/dist;
      const ideal=200, approach=dist>ideal?1:-1;
      e.x += (adx/dist)*e.speed*approach*0.6 + perpX*e.strafeDir*e.speed*0.9;
      e.y += (ady/dist)*e.speed*approach*0.6 + perpY*e.strafeDir*e.speed*0.9;
    } else {
      // Bomber: slow, stops at range, then fires burst
      if (dist>220) { e.x+=(adx/dist)*e.speed; e.y+=(ady/dist)*e.speed; }
    }

    // Clamp to canvas
    e.x=Math.max(-50,Math.min(canvas.width+50,e.x));
    e.y=Math.max(-50,Math.min(canvas.height+50,e.y));

    if (++e.shootTimer >= e.shootDelay){
      e.shootTimer=0;
      if (e.type==='bomber') {
        // Burst: 3-5 bullets spread
        const count=3+Math.floor(Math.random()*3);
        for(let i=0;i<count;i++){
          const spread=(i-(count-1)/2)*0.25;
          const ba=Math.atan2(ady,adx)+spread;
          enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(ba)*3.5,vy:Math.sin(ba)*3.5,boss:false});
        }
      } else {
        fireEnemyBullet(e);
      }
    }
  });

  // Bullet ↔ enemy
  bullets = bullets.filter(b => {
    for (let i=enemies.length-1;i>=0;i--) {
      const e=enemies[i];
      if (hitCB(b.x,b.y,5,e.x,e.y,e.w,e.h)) {
        e.hp -= 20;
        spawnParticles(b.x,b.y,e.color,4);
        if (e.hp<=0){
          spawnParticles(e.x,e.y,e.color,20);
          // Combo system
          combo++; comboTimer=COMBO_DECAY;
          comboMultiplier = combo>=10?5:combo>=6?3:combo>=3?2:1;
          const pts = e.pts * comboMultiplier;
          score += pts; updateHUD();
          const label = combo>=2 ? `COMBO x${combo}! +${pts}` : `+${pts}`;
          scorePopup(e.x, e.y, label, combo>=2?'combo':'');
          enemies.splice(i,1);
        }
        return false;
      }
    }
    // Boss bullet hit
    if (boss && bossState==='active') {
      if (hitCB(b.x,b.y,5,boss.x,boss.y,boss.w,boss.h)) {
        boss.hp -= 20;
        spawnParticles(b.x,b.y,'#ff88ff',5);
        if (boss.hp<=0) defeatBoss();
        return false;
      }
    }
    return true;
  });

  // Combo decay
  if (comboTimer>0) { comboTimer--; } else { combo=0; comboMultiplier=1; }

  // Enemy ↔ player
  if (player.invincible===0) {
    for (const e of enemies) {
      if (hitCB(player.x,player.y,player.w*.4,e.x,e.y,e.w,e.h)) {
        hp=Math.max(0,hp-12); player.invincible=60;
        spawnParticles(player.x,player.y,'#ff0033',10);
        triggerShake(7,15);
        updateHUD(); if(hp<=0) { triggerShake(18,40); gameOver(); } break;
      }
    }
  }

  // Particles & stars
  particles = particles.filter(p=>{ p.x+=p.vx; p.y+=p.vy; p.vx*=.94; p.vy*=.94; return --p.life>0; });
  stars.forEach(s=>{ s.y+=s.speed; if(s.y>canvas.height){s.y=0;s.x=Math.random()*canvas.width;} });

  // Medkit spawn every 10 seconds
  if (++medkitTimer >= MEDKIT_INTERVAL) {
    medkitTimer = 0;
    spawnMedkit();
  }

  // Medkit pickup
  medkits = medkits.filter(m => {
    m.pulse = (m.pulse || 0) + 0.05;
    if (hitCB(player.x, player.y, player.w * 0.6, m.x, m.y, m.size, m.size)) {
      hp = Math.min(100, hp + 40);
      updateHUD();
      spawnParticles(m.x, m.y, '#00ff88', 20);
      scorePopup(m.x, m.y - 20, '+40 HP');
      return false;
    }
    return true;
  });
}

function hitCB(cx,cy,cr,rx,ry,rw,rh) {
  const nx=Math.max(rx-rw/2,Math.min(cx,rx+rw/2));
  const ny=Math.max(ry-rh/2,Math.min(cy,ry+rh/2));
  return Math.hypot(cx-nx,cy-ny)<cr;
}
function fireBullet() {
  const dir = player.angle - Math.PI / 2;
  const spd = 10;
  // Perpendicular offset to place bullets at left and right gun hardpoints
  const perpX = Math.cos(player.angle) * 10.5;
  const perpY = Math.sin(player.angle) * 10.5;
  // Forward offset along firing direction
  const fwdX = Math.cos(dir) * 14;
  const fwdY = Math.sin(dir) * 14;
  // Left barrel
  bullets.push({ x: player.x - perpX + fwdX, y: player.y - perpY + fwdY, vx: Math.cos(dir)*spd, vy: Math.sin(dir)*spd });
  // Right barrel
  bullets.push({ x: player.x + perpX + fwdX, y: player.y + perpY + fwdY, vx: Math.cos(dir)*spd, vy: Math.sin(dir)*spd });
}
function fireEnemyBullet(e) {
  const adx=player.x-e.x,ady=player.y-e.y,d=Math.hypot(adx,ady)||1;
  enemyBullets.push({x:e.x,y:e.y,vx:(adx/d)*4,vy:(ady/d)*4});
}
function spawnParticles(x,y,color,n) {
  for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2,s=Math.random()*4+1;
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,color,life:30+Math.random()*20,maxLife:50});}
}
function scorePopup(x,y,text,cls='') {
  const el=document.createElement('div');
  el.className='score-popup'+(cls?' '+cls:'');
  el.textContent=text;
  el.style.left=x+'px'; el.style.top=y+'px';
  el.style.transform='translateX(-50%)'; // center on x
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), cls==='boss-kill'?1400:900);
}
function gameOver() {
  state='over'; finalScoreEl.textContent=score; showScreen('over');
}
function updateHUD() {
  scoreDisp.textContent = score;
}

// ══════════════════════════════════════════════════════
//  DRAW
// ══════════════════════════════════════════════════════
function drawBG() {
  const g=ctx.createRadialGradient(canvas.width/2,canvas.height/2,0,canvas.width/2,canvas.height/2,canvas.width*.7);
  g.addColorStop(0,'#0d0018'); g.addColorStop(1,'#030008');
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  stars.forEach(s=>{
    ctx.save(); ctx.globalAlpha=s.alpha; ctx.fillStyle=s.red?'#ff3355':'#fff';
    if(s.red){ctx.shadowBlur=6;ctx.shadowColor='#ff0033';}
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.restore();
  });
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBG();
  if (state==='menu'||state==='over'||state==='paused') return;

  // Apply screen shake via canvas translation
  ctx.save();
  if (shakeX || shakeY) ctx.translate(shakeX, shakeY);

  drawPlayer();
  enemies.forEach(drawEnemy);
  medkits.forEach(drawMedkit);
  if (bossState==='active') drawBoss();

  // Player bullets
  bullets.forEach(b=>{
    ctx.save();
    const angle=Math.atan2(b.vy,b.vx);
    ctx.translate(b.x,b.y); ctx.rotate(angle+Math.PI/2);
    ctx.shadowBlur=16; ctx.shadowColor='#ff0033';
    const g=ctx.createLinearGradient(0,-8,0,8);
    g.addColorStop(0,'#fff'); g.addColorStop(.4,'#ff3355'); g.addColorStop(1,'transparent');
    ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(0,0,3,8,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // Enemy + boss bullets
  enemyBullets.forEach(b=>{
    ctx.save();
    const r = b.r||4;
    ctx.shadowBlur=b.boss?20:14;
    ctx.shadowColor=b.laser?'#00ffff':b.boss?'#ff00ff':'#ff6600';
    ctx.fillStyle=b.laser?'#88ffff':b.boss?'#ff44ff':'#ff8844';
    ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  particles.forEach(p=>{
    const a=p.life/p.maxLife;
    ctx.save(); ctx.globalAlpha=a; ctx.shadowBlur=8; ctx.shadowColor=p.color; ctx.fillStyle=p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,2*a+.5,0,Math.PI*2); ctx.fill(); ctx.restore();
  });

  ctx.restore(); // end shake transform

  // UI overlays (drawn outside shake so they stay stable)
  drawBossWarning();
  drawComboMeter();
}

function drawPlayer() {
  const {x, y, invincible, angle} = player;
  if (invincible > 0 && Math.floor(invincible / 5) % 2 === 0) return;

  const t = Date.now();
  const engineFlicker = 0.5 + 0.5 * Math.sin(t * 0.025);
  const engineFlicker2 = 0.5 + 0.5 * Math.sin(t * 0.018 + 1.2);

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // ── ENGINE TRAILS (drawn first, behind ship) ──
  // Left engine exhaust
  const le = ctx.createRadialGradient(-11, 22, 0, -11, 22, 14 * engineFlicker2);
  le.addColorStop(0,   'rgba(120,180,255,1)');
  le.addColorStop(0.3, 'rgba(60,100,255,0.8)');
  le.addColorStop(1,   'transparent');
  ctx.fillStyle = le;
  ctx.shadowBlur = 18; ctx.shadowColor = '#4488ff';
  ctx.beginPath();
  ctx.ellipse(-11, 24, 4, 13 * engineFlicker2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Right engine exhaust
  const re = ctx.createRadialGradient(11, 22, 0, 11, 22, 14 * engineFlicker);
  re.addColorStop(0,   'rgba(120,180,255,1)');
  re.addColorStop(0.3, 'rgba(60,100,255,0.8)');
  re.addColorStop(1,   'transparent');
  ctx.fillStyle = re;
  ctx.shadowBlur = 18; ctx.shadowColor = '#4488ff';
  ctx.beginPath();
  ctx.ellipse(11, 24, 4, 13 * engineFlicker, 0, 0, Math.PI * 2);
  ctx.fill();

  // ── MAIN HULL BODY ──
  ctx.shadowBlur = 0;
  const hullGrad = ctx.createLinearGradient(-20, -28, 20, 28);
  hullGrad.addColorStop(0,   '#d0e8ff');
  hullGrad.addColorStop(0.3, '#7ab0e0');
  hullGrad.addColorStop(0.7, '#3a6fa8');
  hullGrad.addColorStop(1,   '#1a3a5c');
  ctx.fillStyle = hullGrad;
  ctx.shadowBlur = 14; ctx.shadowColor = '#66aaff';

  // Central fuselage — sleek pointed body
  ctx.beginPath();
  ctx.moveTo(0, -28);          // nose tip
  ctx.bezierCurveTo(5, -18, 8, -8, 7, 4);   // right fuselage
  ctx.lineTo(7, 16);
  ctx.lineTo(4, 20);
  ctx.lineTo(-4, 20);
  ctx.lineTo(-7, 16);
  ctx.lineTo(-7, 4);
  ctx.bezierCurveTo(-8, -8, -5, -18, 0, -28); // left fuselage
  ctx.closePath();
  ctx.fill();

  // ── LEFT WING ──
  const wingL = ctx.createLinearGradient(-28, 0, -6, 0);
  wingL.addColorStop(0,   '#1a3a5c');
  wingL.addColorStop(0.5, '#3a6fa8');
  wingL.addColorStop(1,   '#5a8fc8');
  ctx.fillStyle = wingL;
  ctx.shadowBlur = 8; ctx.shadowColor = '#4488ff';
  ctx.beginPath();
  ctx.moveTo(-7, 0);           // wing root top
  ctx.lineTo(-30, 18);         // wingtip
  ctx.lineTo(-26, 22);         // wingtip trailing
  ctx.lineTo(-14, 20);         // wing trailing inner
  ctx.lineTo(-7, 16);          // wing root bottom
  ctx.closePath();
  ctx.fill();

  // ── RIGHT WING ──
  const wingR = ctx.createLinearGradient(6, 0, 28, 0);
  wingR.addColorStop(0,   '#5a8fc8');
  wingR.addColorStop(0.5, '#3a6fa8');
  wingR.addColorStop(1,   '#1a3a5c');
  ctx.fillStyle = wingR;
  ctx.beginPath();
  ctx.moveTo(7, 0);
  ctx.lineTo(30, 18);
  ctx.lineTo(26, 22);
  ctx.lineTo(14, 20);
  ctx.lineTo(7, 16);
  ctx.closePath();
  ctx.fill();

  // ── WING ACCENT LINES (panel details) ──
  ctx.strokeStyle = 'rgba(150,210,255,0.5)';
  ctx.lineWidth = 0.8;
  ctx.shadowBlur = 4; ctx.shadowColor = '#88ccff';
  // Left wing line
  ctx.beginPath(); ctx.moveTo(-8, 4); ctx.lineTo(-24, 18); ctx.stroke();
  // Right wing line
  ctx.beginPath(); ctx.moveTo(8, 4); ctx.lineTo(24, 18); ctx.stroke();

  // ── ENGINE PODS (on wings) ──
  // Left pod
  ctx.fillStyle = '#2a5070';
  ctx.shadowBlur = 6; ctx.shadowColor = '#4488ff';
  ctx.beginPath();
  ctx.roundRect(-17, 8, 9, 14, 3);
  ctx.fill();
  ctx.strokeStyle = 'rgba(100,180,255,0.6)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Right pod
  ctx.beginPath();
  ctx.roundRect(8, 8, 9, 14, 3);
  ctx.fill();
  ctx.stroke();

  // ── HULL PANEL LINES ──
  ctx.strokeStyle = 'rgba(180,220,255,0.3)';
  ctx.lineWidth = 0.7;
  ctx.shadowBlur = 0;
  // Center spine
  ctx.beginPath(); ctx.moveTo(0, -26); ctx.lineTo(0, 18); ctx.stroke();
  // Side panels
  ctx.beginPath(); ctx.moveTo(-5, -10); ctx.lineTo(-6, 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(5, -10); ctx.lineTo(6, 10); ctx.stroke();

  // ── COCKPIT CANOPY ──
  ctx.shadowBlur = 16; ctx.shadowColor = '#00eeff';
  const canopy = ctx.createRadialGradient(-1.5, -16, 1, 0, -14, 8);
  canopy.addColorStop(0,   'rgba(200,240,255,0.95)');
  canopy.addColorStop(0.4, 'rgba(80,200,240,0.85)');
  canopy.addColorStop(1,   'rgba(0,80,160,0.7)');
  ctx.fillStyle = canopy;
  ctx.beginPath();
  ctx.ellipse(0, -14, 4.5, 9, 0, 0, Math.PI * 2);
  ctx.fill();

  // Canopy highlight glint
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.shadowBlur = 4;
  ctx.beginPath();
  ctx.ellipse(-1.2, -18, 1.2, 2.5, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // ── NOSE TIP GLOW ──
  ctx.shadowBlur = 20; ctx.shadowColor = '#ffffff';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.beginPath();
  ctx.arc(0, -28, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // ── WEAPON HARDPOINTS (small gun barrels under wings) ──
  ctx.fillStyle = '#1a3050';
  ctx.shadowBlur = 0;
  ctx.beginPath(); ctx.roundRect(-22, 14, 3, 7, 1); ctx.fill();
  ctx.beginPath(); ctx.roundRect(19, 14, 3, 7, 1); ctx.fill();

  // Gun barrel tips glow when shooting
  if (player.shootCooldown > player.shootDelay - 4) {
    ctx.shadowBlur = 14; ctx.shadowColor = '#ffaa00';
    ctx.fillStyle = 'rgba(255,180,0,0.9)';
    ctx.beginPath(); ctx.arc(-20.5, 21, 2.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(20.5, 21, 2.5, 0, Math.PI*2); ctx.fill();
  }

  // ── HP BAR ABOVE SHIP (drawn in world space, unrotated) ──
  ctx.restore(); // end ship rotation

  ctx.save();
  ctx.translate(x, y); // back to player center, no rotation

  const barW  = 54;
  const barH  = 6;
  const barX  = -barW / 2;
  const barY  = -52; // above the nose tip

  // Drop shadow for readability
  ctx.shadowBlur  = 8;
  ctx.shadowColor = 'rgba(0,0,0,0.8)';

  // Background track
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.beginPath();
  ctx.roundRect(barX - 1, barY - 1, barW + 2, barH + 2, 3);
  ctx.fill();

  // Colored fill — green → yellow → red based on hp
  const hpRatio = hp / 100;
  let barColor;
  if (hpRatio > 0.6)       barColor = `rgba(0,220,100,0.95)`;
  else if (hpRatio > 0.3)  barColor = `rgba(255,200,0,0.95)`;
  else                     barColor = `rgba(255,40,40,0.95)`;

  ctx.shadowBlur  = 6;
  ctx.shadowColor = barColor;
  ctx.fillStyle   = barColor;
  ctx.beginPath();
  ctx.roundRect(barX, barY, barW * hpRatio, barH, 2);
  ctx.fill();

  // Border
  ctx.shadowBlur  = 0;
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth   = 0.8;
  ctx.beginPath();
  ctx.roundRect(barX - 1, barY - 1, barW + 2, barH + 2, 3);
  ctx.stroke();

  // HP number
  ctx.shadowBlur  = 6;
  ctx.shadowColor = barColor;
  ctx.fillStyle   = '#ffffff';
  ctx.font        = 'bold 8px "Orbitron", monospace';
  ctx.textAlign   = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(hp + ' HP', 0, barY - 3);

  ctx.restore();
}

function drawMedkit(m) {
  const { x, y, size, pulse } = m;
  const s = size / 2;
  const glow = 8 + Math.sin(pulse) * 5;
  const scale = 1 + Math.sin(pulse) * 0.06;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);

  // Outer glow ring
  ctx.shadowBlur  = glow * 3;
  ctx.shadowColor = '#00ff88';

  // Background circle
  const bg = ctx.createRadialGradient(0, 0, 0, 0, 0, s);
  bg.addColorStop(0,   'rgba(0,40,20,.95)');
  bg.addColorStop(0.7, 'rgba(0,80,40,.9)');
  bg.addColorStop(1,   'rgba(0,200,100,.7)');
  ctx.fillStyle = bg;
  ctx.beginPath();
  ctx.arc(0, 0, s, 0, Math.PI * 2);
  ctx.fill();

  // Green border
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth   = 2.5;
  ctx.shadowBlur  = glow;
  ctx.beginPath();
  ctx.arc(0, 0, s, 0, Math.PI * 2);
  ctx.stroke();

  // White cross — horizontal bar
  ctx.fillStyle   = '#ffffff';
  ctx.shadowBlur  = 10;
  ctx.shadowColor = '#aaffcc';
  const cw = s * 0.55, ch = s * 0.22;
  ctx.fillRect(-cw, -ch, cw * 2, ch * 2);
  // vertical bar
  ctx.fillRect(-ch, -cw, ch * 2, cw * 2);

  // Pulsing outer ring
  const ringAlpha = 0.3 + 0.3 * Math.sin(pulse * 1.5);
  ctx.strokeStyle = `rgba(0,255,136,${ringAlpha})`;
  ctx.lineWidth   = 2;
  ctx.shadowBlur  = 20;
  ctx.beginPath();
  ctx.arc(0, 0, s + 8 + Math.sin(pulse) * 4, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
}

function drawEnemy(e) {
  const t = Date.now();
  ctx.save();
  ctx.translate(e.x, e.y);
  ctx.rotate(e.angle || 0);

  if (e.type === 'scout') {
    drawScout(e, t);
  } else if (e.type === 'fighter') {
    drawFighter(e, t);
  } else {
    drawBomber(e, t);
  }

  // HP bar — always unrotated, above ship
  if (e.hp < e.maxHp) {
    ctx.rotate(-(e.angle || 0));
    const bw = e.w + 14, bh = 5, bx = -bw/2, by = -e.w/2 - 14;
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.beginPath(); ctx.roundRect(bx-1, by-1, bw+2, bh+2, 2); ctx.fill();
    const ratio = e.hp / e.maxHp;
    ctx.fillStyle = ratio > 0.6 ? '#ff3355' : ratio > 0.3 ? '#ff6600' : '#ff0000';
    ctx.shadowBlur = 6; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath(); ctx.roundRect(bx, by, bw * ratio, bh, 2); ctx.fill();
  }

  ctx.restore();
}

// ── SCOUT: fast red interceptor — sleek arrowhead with swept wings ──
function drawScout(e, t) {
  const flicker = 0.5 + 0.5 * Math.sin(t * 0.03);
  const s = e.w / 2;

  // Engine trail (behind)
  const eng = ctx.createRadialGradient(0, s*0.6, 0, 0, s*0.6, 10*flicker);
  eng.addColorStop(0,   'rgba(255,80,0,1)');
  eng.addColorStop(0.4, 'rgba(200,20,0,0.7)');
  eng.addColorStop(1,   'transparent');
  ctx.fillStyle = eng;
  ctx.shadowBlur = 14; ctx.shadowColor = '#ff4400';
  ctx.beginPath(); ctx.ellipse(0, s*0.55, 3.5, 10*flicker, 0, 0, Math.PI*2); ctx.fill();

  // Main body — dark crimson hull
  const hull = ctx.createLinearGradient(-s*0.5, -s, s*0.5, s);
  hull.addColorStop(0,   '#ff2244');
  hull.addColorStop(0.4, '#991122');
  hull.addColorStop(1,   '#440008');
  ctx.fillStyle = hull;
  ctx.shadowBlur = 18; ctx.shadowColor = '#ff0033';
  // Pointed fuselage
  ctx.beginPath();
  ctx.moveTo(0, -s);                               // nose
  ctx.bezierCurveTo(s*0.3, -s*0.5, s*0.35, 0, s*0.25, s*0.5);
  ctx.lineTo(0, s*0.7);
  ctx.lineTo(-s*0.25, s*0.5);
  ctx.bezierCurveTo(-s*0.35, 0, -s*0.3, -s*0.5, 0, -s);
  ctx.closePath(); ctx.fill();

  // Left swept wing
  const wL = ctx.createLinearGradient(-s, s*0.2, -s*0.25, -s*0.1);
  wL.addColorStop(0, '#330008'); wL.addColorStop(1, '#cc1133');
  ctx.fillStyle = wL; ctx.shadowBlur = 6;
  ctx.beginPath();
  ctx.moveTo(-s*0.25, -s*0.1);
  ctx.lineTo(-s, s*0.5);
  ctx.lineTo(-s*0.8, s*0.65);
  ctx.lineTo(-s*0.25, s*0.4);
  ctx.closePath(); ctx.fill();

  // Right swept wing
  const wR = ctx.createLinearGradient(s*0.25, -s*0.1, s, s*0.2);
  wR.addColorStop(0, '#cc1133'); wR.addColorStop(1, '#330008');
  ctx.fillStyle = wR;
  ctx.beginPath();
  ctx.moveTo(s*0.25, -s*0.1);
  ctx.lineTo(s, s*0.5);
  ctx.lineTo(s*0.8, s*0.65);
  ctx.lineTo(s*0.25, s*0.4);
  ctx.closePath(); ctx.fill();

  // Wing edge glow lines
  ctx.strokeStyle = 'rgba(255,60,80,0.7)'; ctx.lineWidth = 1;
  ctx.shadowBlur = 8; ctx.shadowColor = '#ff2244';
  ctx.beginPath(); ctx.moveTo(-s*0.25,-s*0.1); ctx.lineTo(-s, s*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s*0.25,-s*0.1); ctx.lineTo(s, s*0.5); ctx.stroke();

  // Cockpit sensor eye — single glowing red orb
  ctx.shadowBlur = 16; ctx.shadowColor = '#ff0000';
  const eye = ctx.createRadialGradient(0, -s*0.35, 0, 0, -s*0.35, s*0.18);
  eye.addColorStop(0, 'rgba(255,255,100,1)');
  eye.addColorStop(0.4, 'rgba(255,40,40,0.9)');
  eye.addColorStop(1, 'rgba(100,0,0,0)');
  ctx.fillStyle = eye;
  ctx.beginPath(); ctx.arc(0, -s*0.35, s*0.18, 0, Math.PI*2); ctx.fill();

  // Hull panel line
  ctx.strokeStyle = 'rgba(255,100,120,0.3)'; ctx.lineWidth = 0.7; ctx.shadowBlur = 0;
  ctx.beginPath(); ctx.moveTo(0, -s*0.9); ctx.lineTo(0, s*0.6); ctx.stroke();
}

// ── FIGHTER: medium orange/gold warship — wide delta with heavy armor ──
function drawFighter(e, t) {
  const flicker  = 0.5 + 0.5 * Math.sin(t * 0.022);
  const flicker2 = 0.5 + 0.5 * Math.sin(t * 0.028 + 0.8);
  const s = e.w / 2;

  // Dual engine exhausts
  for (const ox of [-s*0.38, s*0.38]) {
    const f = ox < 0 ? flicker : flicker2;
    const eng = ctx.createRadialGradient(ox, s*0.5, 0, ox, s*0.5, 9*f);
    eng.addColorStop(0,   'rgba(255,160,0,1)');
    eng.addColorStop(0.4, 'rgba(200,80,0,0.7)');
    eng.addColorStop(1,   'transparent');
    ctx.fillStyle = eng;
    ctx.shadowBlur = 14; ctx.shadowColor = '#ff8800';
    ctx.beginPath(); ctx.ellipse(ox, s*0.5, 3, 8*f, 0, 0, Math.PI*2); ctx.fill();
  }

  // Main hull — armored orange-dark fuselage
  const hull = ctx.createLinearGradient(-s*0.4, -s, s*0.4, s);
  hull.addColorStop(0,   '#ff8833');
  hull.addColorStop(0.35,'#cc4400');
  hull.addColorStop(0.7, '#7a2200');
  hull.addColorStop(1,   '#3a0e00');
  ctx.fillStyle = hull; ctx.shadowBlur = 16; ctx.shadowColor = '#ff6600';
  ctx.beginPath();
  ctx.moveTo(0, -s);
  ctx.bezierCurveTo(s*0.4, -s*0.6, s*0.5, -s*0.1, s*0.4, s*0.3);
  ctx.lineTo(s*0.25, s*0.7);
  ctx.lineTo(-s*0.25, s*0.7);
  ctx.lineTo(-s*0.4, s*0.3);
  ctx.bezierCurveTo(-s*0.5, -s*0.1, -s*0.4, -s*0.6, 0, -s);
  ctx.closePath(); ctx.fill();

  // Wide delta wings
  const wHull = ctx.createLinearGradient(-s, 0, s, 0);
  wHull.addColorStop(0,   '#2a0e00');
  wHull.addColorStop(0.3, '#7a2800');
  wHull.addColorStop(0.5, '#cc4400');
  wHull.addColorStop(0.7, '#7a2800');
  wHull.addColorStop(1,   '#2a0e00');
  ctx.fillStyle = wHull; ctx.shadowBlur = 8;
  ctx.beginPath();
  ctx.moveTo(-s*0.4, -s*0.2);
  ctx.lineTo(-s, s*0.6);
  ctx.lineTo(-s*0.8, s*0.75);
  ctx.lineTo(-s*0.35, s*0.6);
  ctx.lineTo(-s*0.25, s*0.7);
  ctx.lineTo(s*0.25, s*0.7);
  ctx.lineTo(s*0.35, s*0.6);
  ctx.lineTo(s*0.8, s*0.75);
  ctx.lineTo(s, s*0.6);
  ctx.lineTo(s*0.4, -s*0.2);
  ctx.closePath(); ctx.fill();

  // Wing leading edge glow
  ctx.strokeStyle = 'rgba(255,120,0,0.65)'; ctx.lineWidth = 1.2;
  ctx.shadowBlur = 10; ctx.shadowColor = '#ff8800';
  ctx.beginPath(); ctx.moveTo(-s*0.4,-s*0.2); ctx.lineTo(-s, s*0.6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s*0.4,-s*0.2); ctx.lineTo(s, s*0.6); ctx.stroke();

  // Armor plating panels
  ctx.strokeStyle = 'rgba(255,160,60,0.25)'; ctx.lineWidth = 0.8; ctx.shadowBlur = 0;
  ctx.beginPath(); ctx.moveTo(-s*0.35,-s*0.4); ctx.lineTo(-s*0.42, s*0.1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s*0.35,-s*0.4); ctx.lineTo(s*0.42, s*0.1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-s*0.2, -s*0.1); ctx.lineTo(-s*0.2, s*0.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(s*0.2, -s*0.1); ctx.lineTo(s*0.2, s*0.5); ctx.stroke();

  // Turret on top of hull
  ctx.shadowBlur = 8; ctx.shadowColor = '#ffaa00';
  ctx.fillStyle = '#5a2800';
  ctx.beginPath(); ctx.roundRect(-s*0.15, -s*0.5, s*0.3, s*0.25, 3); ctx.fill();
  ctx.strokeStyle = 'rgba(255,160,0,0.5)'; ctx.lineWidth = 1;
  ctx.stroke();
  // Turret barrel
  ctx.fillStyle = '#331500';
  ctx.beginPath(); ctx.roundRect(-s*0.05, -s*0.65, s*0.1, s*0.2, 2); ctx.fill();

  // Cockpit visor
  ctx.shadowBlur = 12; ctx.shadowColor = '#ff4400';
  const visor = ctx.createRadialGradient(-1, -s*0.22, 0, 0, -s*0.22, s*0.22);
  visor.addColorStop(0,   'rgba(255,200,100,0.9)');
  visor.addColorStop(0.5, 'rgba(255,80,0,0.8)');
  visor.addColorStop(1,   'rgba(80,10,0,0)');
  ctx.fillStyle = visor;
  ctx.beginPath(); ctx.ellipse(0, -s*0.22, s*0.2, s*0.13, 0, 0, Math.PI*2); ctx.fill();
}

// ── BOMBER: massive purple dreadnought — hexagonal fortress with weapon arrays ──
function drawBomber(e, t) {
  const pulse  = 0.5 + 0.5 * Math.sin(t * 0.015);
  const pulse2 = 0.5 + 0.5 * Math.sin(t * 0.012 + 1.5);
  const s = e.w / 2;

  // Three engine exhausts
  for (const [ox, p] of [[-s*0.45, pulse], [0, pulse2], [s*0.45, pulse]]) {
    const eng = ctx.createRadialGradient(ox, s*0.55, 0, ox, s*0.55, 11*p);
    eng.addColorStop(0,   'rgba(200,0,255,1)');
    eng.addColorStop(0.4, 'rgba(100,0,180,0.7)');
    eng.addColorStop(1,   'transparent');
    ctx.fillStyle = eng; ctx.shadowBlur = 16; ctx.shadowColor = '#cc00ff';
    ctx.beginPath(); ctx.ellipse(ox, s*0.55, 3.5, 10*p, 0, 0, Math.PI*2); ctx.fill();
  }

  // Outer armor shell — thick hexagonal shape
  const shell = ctx.createLinearGradient(-s, -s, s, s);
  shell.addColorStop(0,   '#cc44ff');
  shell.addColorStop(0.3, '#7700bb');
  shell.addColorStop(0.7, '#440077');
  shell.addColorStop(1,   '#1a0030');
  ctx.fillStyle = shell; ctx.shadowBlur = 22; ctx.shadowColor = '#aa00ff';
  ctx.beginPath();
  ctx.moveTo(0, -s);
  ctx.lineTo(s*0.75, -s*0.5);
  ctx.lineTo(s*0.85, s*0.1);
  ctx.lineTo(s*0.55, s*0.7);
  ctx.lineTo(-s*0.55, s*0.7);
  ctx.lineTo(-s*0.85, s*0.1);
  ctx.lineTo(-s*0.75, -s*0.5);
  ctx.closePath(); ctx.fill();

  // Inner armored core
  const core = ctx.createRadialGradient(0, 0, 0, 0, 0, s*0.55);
  core.addColorStop(0,   '#ff88ff');
  core.addColorStop(0.4, '#9900cc');
  core.addColorStop(1,   '#330055');
  ctx.fillStyle = core; ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.moveTo(0, -s*0.55);
  ctx.lineTo(s*0.45, -s*0.28);
  ctx.lineTo(s*0.45, s*0.28);
  ctx.lineTo(0, s*0.55);
  ctx.lineTo(-s*0.45, s*0.28);
  ctx.lineTo(-s*0.45, -s*0.28);
  ctx.closePath(); ctx.fill();

  // Armor panel lines
  ctx.strokeStyle = 'rgba(220,100,255,0.4)'; ctx.lineWidth = 1; ctx.shadowBlur = 6; ctx.shadowColor = '#cc66ff';
  const pts = [[0,-s],[s*0.75,-s*0.5],[s*0.85,s*0.1],[s*0.55,s*0.7],[-s*0.55,s*0.7],[-s*0.85,s*0.1],[-s*0.75,-s*0.5]];
  for (const [px,py] of pts) { ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(px*0.6,py*0.6); ctx.stroke(); }

  // Side weapon pods
  for (const ox of [-s*0.82, s*0.82]) {
    ctx.fillStyle = '#2a0044'; ctx.shadowBlur = 8; ctx.shadowColor = '#9900ff';
    ctx.beginPath(); ctx.roundRect(ox - s*0.12, -s*0.12, s*0.22, s*0.35, 4); ctx.fill();
    ctx.strokeStyle = 'rgba(180,0,255,0.6)'; ctx.lineWidth = 1; ctx.stroke();
    // Weapon barrel tip glow
    const wpGlow = 0.4 + 0.6 * Math.sin(t * 0.04 + (ox > 0 ? 0 : Math.PI));
    ctx.shadowBlur = 12 * wpGlow; ctx.shadowColor = '#ff00ff';
    ctx.fillStyle = `rgba(255,100,255,${wpGlow * 0.9})`;
    ctx.beginPath(); ctx.arc(ox, -s*0.14, s*0.07, 0, Math.PI*2); ctx.fill();
  }

  // Central energy core — pulsing
  const coreGlow = 0.6 + 0.4 * Math.sin(t * 0.02);
  const coreRad = ctx.createRadialGradient(0, 0, 0, 0, 0, s*0.22*coreGlow);
  coreRad.addColorStop(0,   `rgba(255,255,255,${coreGlow})`);
  coreRad.addColorStop(0.3, `rgba(220,0,255,${coreGlow*0.9})`);
  coreRad.addColorStop(1,   'transparent');
  ctx.fillStyle = coreRad; ctx.shadowBlur = 24*coreGlow; ctx.shadowColor = '#ff00ff';
  ctx.beginPath(); ctx.arc(0, 0, s*0.22, 0, Math.PI*2); ctx.fill();

  // Outer ring
  ctx.strokeStyle = `rgba(255,100,255,${0.3+0.3*Math.sin(t*0.02)})`;
  ctx.lineWidth = 1.5; ctx.shadowBlur = 10;
  ctx.beginPath(); ctx.arc(0, 0, s*0.35, 0, Math.PI*2); ctx.stroke();

  // Sensor array at top
  ctx.shadowBlur = 10; ctx.shadowColor = '#ff44ff';
  ctx.fillStyle = '#1a0030';
  ctx.beginPath(); ctx.roundRect(-s*0.12, -s*0.88, s*0.24, s*0.2, 3); ctx.fill();
  // Sensor dish
  ctx.strokeStyle = 'rgba(220,100,255,0.8)'; ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.arc(0, -s*0.78, s*0.1, Math.PI, 0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -s*0.88); ctx.lineTo(0, -s*0.68); ctx.stroke();
}

// ══════════════════════════════════════════════════════
//  SINGLE MASTER LOOP — handles every state
// ══════════════════════════════════════════════════════
// ══════════════════════════════════════════════════════
//  SCREEN SHAKE
// ══════════════════════════════════════════════════════
function triggerShake(intensity, duration) {
  if (intensity > shakeIntensity) {
    shakeIntensity = intensity;
    shakeDuration  = duration;
  }
}
function updateShake() {
  if (shakeDuration > 0) {
    shakeDuration--;
    // Intensity decays exponentially
    shakeIntensity *= 0.85;
    const decay = shakeDuration / 20;
    shakeX = (Math.random()*2-1) * shakeIntensity * Math.min(decay, 1);
    shakeY = (Math.random()*2-1) * shakeIntensity * Math.min(decay, 1);
  } else {
    shakeX = 0; shakeY = 0; shakeIntensity = 0;
  }
}

// ══════════════════════════════════════════════════════
//  BOSS SYSTEM
// ══════════════════════════════════════════════════════
function spawnBoss() {
  const bossNum = Math.floor((bossScoreThreshold-1000)/1000)+1;
  const bossHp  = 800 + bossNum*200;
  boss = {
    x: canvas.width/2,
    y: -100,
    w: 110, h: 110,
    hp: bossHp, maxHp: bossHp,
    speed: 0.9,
    angle: Math.PI/2,
    phase: 0,        // attack phase cycle
    phaseTimer: 0,
    attackTimer: 0,
    moveTimer: 0,
    targetX: canvas.width/2,
    targetY: 130,
    entering: true,
    spinAngle: 0,
    num: bossNum,
  };
  bossState = 'active';
  enemies = []; // clear regular enemies
  triggerShake(15, 30);
}

function updateBoss() {
  if (!boss) return;
  boss.spinAngle += 0.012;

  // Entering — fly to arena position
  if (boss.entering) {
    boss.y += 2.2;
    if (boss.y >= boss.targetY) { boss.y = boss.targetY; boss.entering = false; }
    return;
  }

  // Movement: drift toward target point, change target periodically
  boss.moveTimer++;
  if (boss.moveTimer > 180) {
    boss.moveTimer = 0;
    const margin = 140;
    boss.targetX = margin + Math.random()*(canvas.width-margin*2);
    boss.targetY = 100 + Math.random()*(canvas.height*0.42);
  }
  const tdx=boss.targetX-boss.x, tdy=boss.targetY-boss.y, tdist=Math.hypot(tdx,tdy)||1;
  if (tdist>8) { boss.x+=tdx/tdist*boss.speed; boss.y+=tdy/tdist*boss.speed; }

  // Attack cycle
  boss.phaseTimer++;
  const phaseLen = [160,120,140][boss.phase%3];
  if (boss.phaseTimer >= phaseLen) {
    boss.phaseTimer = 0;
    boss.phase++;
    executeBossAttack(boss.phase%3);
  }
}

function executeBossAttack(phase) {
  if (!boss) return;
  const adx=player.x-boss.x, ady=player.y-boss.y;
  const dir=Math.atan2(ady,adx);

  if (phase===0) {
    // Spread shot: 7 bullets in arc
    triggerShake(6,12);
    for(let i=0;i<7;i++){
      const a=dir-0.6+(i/6)*1.2;
      enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*5,vy:Math.sin(a)*5,boss:true,r:7});
    }
  } else if (phase===1) {
    // Laser burst: rapid targeted shots
    triggerShake(8,18);
    for(let i=0;i<5;i++){
      setTimeout(()=>{
        if(!boss||bossState!=='active') return;
        const ba=Math.atan2(player.y-boss.y,player.x-boss.x);
        enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(ba)*7,vy:Math.sin(ba)*7,boss:true,r:5,laser:true});
      }, i*80);
    }
  } else {
    // Radial explosion: 16 bullets in all directions
    triggerShake(12,22);
    for(let i=0;i<16;i++){
      const a=(i/16)*Math.PI*2;
      enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*4,vy:Math.sin(a)*4,boss:true,r:6});
    }
  }
}

function defeatBoss() {
  if (!boss) return;
  bossState = 'dying';
  triggerShake(20, 60);
  // Big explosion
  for(let i=0;i<60;i++) spawnParticles(
    boss.x+(Math.random()-0.5)*boss.w,
    boss.y+(Math.random()-0.5)*boss.h,
    ['#ff00ff','#ff4400','#ffcc00','#ffffff'][Math.floor(Math.random()*4)], 6
  );
  score += 500; updateHUD();
  scorePopup(boss.x, boss.y-40, '⚡ BOSS DOWN! +500', 'boss-kill');
  bossScoreThreshold += 1000;
  spawnInterval = Math.max(40, spawnInterval - 10);
  boss = null;
  setTimeout(()=>{ bossState='none'; }, 2000);
}

// ══════════════════════════════════════════════════════
//  DRAW BOSS
// ══════════════════════════════════════════════════════
function drawBoss() {
  if (!boss) return;
  const {x,y,w,h,spinAngle,hp,maxHp,num} = boss;
  const t = Date.now();
  const pulse = 0.5+0.5*Math.sin(t*0.01);

  ctx.save();
  ctx.translate(x,y);

  // Outer rotating ring
  ctx.save();
  ctx.rotate(spinAngle);
  ctx.shadowBlur=30; ctx.shadowColor='#ff00ff';
  ctx.strokeStyle=`rgba(255,80,255,${0.5+0.4*pulse})`;
  ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(0,0,w*0.62,0,Math.PI*2); ctx.stroke();
  // Ring segments
  for(let i=0;i<8;i++){
    const a=(i/8)*Math.PI*2;
    ctx.save(); ctx.rotate(a);
    ctx.fillStyle=`rgba(180,0,255,${0.7+0.3*pulse})`;
    ctx.shadowBlur=16;
    ctx.beginPath(); ctx.arc(w*0.62,0,5,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  ctx.restore();

  // Counter-rotating inner ring
  ctx.save();
  ctx.rotate(-spinAngle*1.5);
  ctx.strokeStyle=`rgba(255,180,0,${0.4+0.3*pulse})`;
  ctx.lineWidth=1.5; ctx.shadowBlur=12; ctx.shadowColor='#ffaa00';
  ctx.beginPath(); ctx.arc(0,0,w*0.44,0,Math.PI*2); ctx.stroke();
  for(let i=0;i<6;i++){
    const a=(i/6)*Math.PI*2;
    ctx.save(); ctx.rotate(a);
    ctx.fillStyle='rgba(255,160,0,0.8)';
    ctx.beginPath(); ctx.arc(w*0.44,0,4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  ctx.restore();

  // Main body — massive dark hull
  const hull=ctx.createRadialGradient(0,-10,0,0,0,w*0.5);
  hull.addColorStop(0,'#cc00ff');
  hull.addColorStop(0.4,'#660099');
  hull.addColorStop(0.8,'#220033');
  hull.addColorStop(1,'#0a0015');
  ctx.fillStyle=hull; ctx.shadowBlur=40; ctx.shadowColor='#aa00ff';
  // Asymmetric hexagonal hull shape
  ctx.beginPath();
  ctx.moveTo(0,-w*0.5);
  ctx.lineTo(w*0.4,-w*0.3);
  ctx.lineTo(w*0.52,w*0.05);
  ctx.lineTo(w*0.35,w*0.45);
  ctx.lineTo(-w*0.35,w*0.45);
  ctx.lineTo(-w*0.52,w*0.05);
  ctx.lineTo(-w*0.4,-w*0.3);
  ctx.closePath(); ctx.fill();

  // Armor plates
  ctx.strokeStyle='rgba(200,100,255,0.35)'; ctx.lineWidth=1.5; ctx.shadowBlur=6; ctx.shadowColor='#cc66ff';
  for(let i=0;i<6;i++){
    const a=(i/6)*Math.PI*2-Math.PI/6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*w*0.48,Math.sin(a)*w*0.48); ctx.stroke();
  }

  // 4 weapon turrets
  const turretPositions=[[-w*0.35,-w*0.2],[w*0.35,-w*0.2],[-w*0.38,w*0.15],[w*0.38,w*0.15]];
  turretPositions.forEach(([tx,ty])=>{
    ctx.save(); ctx.translate(tx,ty);
    ctx.fillStyle='#330055'; ctx.shadowBlur=10; ctx.shadowColor='#9900ff';
    ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(200,0,255,0.7)'; ctx.lineWidth=1.5; ctx.stroke();
    const glow=0.4+0.6*Math.sin(t*0.03+(tx+ty)*0.01);
    ctx.fillStyle=`rgba(255,0,255,${glow})`;
    ctx.shadowBlur=14*glow; ctx.shadowColor='#ff00ff';
    ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // Central eye — pulsing energy core
  const eyePulse=0.6+0.4*Math.sin(t*0.018);
  const core=ctx.createRadialGradient(0,0,0,0,0,w*0.22*eyePulse);
  core.addColorStop(0,'rgba(255,255,255,1)');
  core.addColorStop(0.3,`rgba(255,0,255,${eyePulse})`);
  core.addColorStop(1,'transparent');
  ctx.fillStyle=core; ctx.shadowBlur=50*eyePulse; ctx.shadowColor='#ff00ff';
  ctx.beginPath(); ctx.arc(0,0,w*0.22,0,Math.PI*2); ctx.fill();

  // Eye ring
  ctx.strokeStyle=`rgba(255,150,255,${0.4+0.4*eyePulse})`;
  ctx.lineWidth=2; ctx.shadowBlur=20;
  ctx.beginPath(); ctx.arc(0,0,w*0.3,0,Math.PI*2); ctx.stroke();

  // BOSS label
  ctx.font=`bold ${11+num}px "Orbitron",monospace`;
  ctx.fillStyle='rgba(255,200,255,0.9)';
  ctx.shadowBlur=10; ctx.shadowColor='#ff88ff';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(`BOSS ${num}`,0,w*0.62);

  ctx.restore();

  // ── BOSS HP BAR at top of screen ──
  const barW=Math.min(canvas.width*0.6,500), barH=18;
  const barX=(canvas.width-barW)/2, barY=14;
  const ratio=Math.max(0,hp/maxHp);

  ctx.save();
  // Background
  ctx.fillStyle='rgba(0,0,0,0.75)';
  ctx.beginPath(); ctx.roundRect(barX-2,barY-2,barW+4,barH+4,5); ctx.fill();
  // Fill
  const barGrad=ctx.createLinearGradient(barX,0,barX+barW,0);
  barGrad.addColorStop(0,'#ff00ff'); barGrad.addColorStop(0.5,'#aa00ff'); barGrad.addColorStop(1,'#ff0066');
  ctx.fillStyle=barGrad;
  ctx.shadowBlur=16; ctx.shadowColor='#cc00ff';
  ctx.beginPath(); ctx.roundRect(barX,barY,barW*ratio,barH,4); ctx.fill();
  // Border
  ctx.strokeStyle='rgba(255,100,255,0.5)'; ctx.lineWidth=1.5; ctx.shadowBlur=0;
  ctx.beginPath(); ctx.roundRect(barX-2,barY-2,barW+4,barH+4,5); ctx.stroke();
  // Text
  ctx.fillStyle='#fff'; ctx.font='bold 10px "Orbitron",monospace';
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowBlur=6; ctx.shadowColor='#ff88ff';
  ctx.fillText(`⚡ BOSS ${num}  ${hp} / ${maxHp}`, canvas.width/2, barY+barH/2);
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  DRAW BOSS WARNING
// ══════════════════════════════════════════════════════
function drawBossWarning() {
  if (bossState!=='warning') return;
  const alpha = Math.min(1, bossWarningTimer < 40 ? bossWarningTimer/40 : 1);
  const scale = 1 + 0.06*Math.sin(Date.now()*0.015);
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(scale,scale);
  // Red flash overlay
  ctx.fillStyle=`rgba(80,0,0,${0.15*Math.sin(Date.now()*0.02)+0.12})`;
  ctx.fillRect(-canvas.width/2,-canvas.height/2,canvas.width,canvas.height);
  // Warning text
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.shadowBlur=40; ctx.shadowColor='#ff0000';
  ctx.fillStyle='#ff2244';
  ctx.font=`bold ${Math.floor(canvas.width*0.055)}px "Orbitron",monospace`;
  ctx.fillText('⚠ BOSS INCOMING ⚠',0,-28);
  ctx.shadowBlur=20;
  ctx.fillStyle='rgba(255,180,180,0.85)';
  ctx.font=`${Math.floor(canvas.width*0.022)}px "Orbitron",monospace`;
  ctx.fillText('PREPARE FOR BATTLE',0,24);
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  DRAW COMBO METER
// ══════════════════════════════════════════════════════
function drawComboMeter() {
  if (combo < 2) return;
  const t = Date.now();
  const pulse = 0.7 + 0.3*Math.sin(t*0.015);
  const label = combo>=10?'x5':combo>=6?'x3':combo>=3?'x2':'';
  const timerRatio = comboTimer/COMBO_DECAY;

  ctx.save();
  ctx.translate(20, 60);

  // Timer bar
  const bw=140, bh=5;
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.beginPath(); ctx.roundRect(0,0,bw,bh,3); ctx.fill();
  const barColor=combo>=10?'#ff3300':combo>=6?'#ff6600':combo>=3?'#ffcc00':'#ff4466';
  ctx.fillStyle=barColor;
  ctx.shadowBlur=8*pulse; ctx.shadowColor=barColor;
  ctx.beginPath(); ctx.roundRect(0,0,bw*timerRatio,bh,3); ctx.fill();

  // Combo text
  ctx.shadowBlur=20*pulse; ctx.shadowColor='#ff2244';
  ctx.fillStyle=`rgba(255,${combo>=10?80:combo>=6?140:200},${combo>=10?50:100},${pulse})`;
  ctx.font=`bold ${18+combo*0.8}px "Orbitron",monospace`;
  ctx.textBaseline='top'; ctx.textAlign='left';
  ctx.fillText(`COMBO ${combo}${label?'  '+label:''}`,0,10);

  ctx.restore();
}

function masterLoop() {
  // Always tick stars for menu/over background animation
  if (state === 'menu' || state === 'over') {
    stars.forEach(s => { s.y += s.speed; if(s.y>canvas.height){s.y=0;s.x=Math.random()*canvas.width;} });
  }
  if (state === 'playing') {
    update();
    updateShake();
  }
  draw();
  requestAnimationFrame(masterLoop);
}

initStars();
masterLoop();

</script>
</body>
</html>
